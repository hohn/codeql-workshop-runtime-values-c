* CodeQL Workshop --- Using Data-Flow and Range Analysis to Find Out-Of-Bounds Accesses
:PROPERTIES:
:CUSTOM_ID: codeql-workshop--using-data-flow-and-range-analysis-to-find-out-of-bounds-accesses
:END:
* Acknowledgements
  :PROPERTIES:
  :CUSTOM_ID: acknowledgements
  :END:

This session-based workshop is based on the exercise/unit-test-based material at
https://github.com/kraiouchkine/codeql-workshop-runtime-values-c, which in turn is
based on a significantly simplified and modified version of the
[[https://github.com/github/codeql-coding-standards/blob/main/c/common/src/codingstandards/c/OutOfBounds.qll][OutOfBounds.qll library]] from the
[[https://github.com/github/codeql-coding-standards][CodeQL Coding Standards
repository]]. 

* Setup Instructions
  :PROPERTIES:
  :CUSTOM_ID: setup-instructions
  :END:
- Install [[https://code.visualstudio.com/][Visual Studio Code]].

- Install the
  [[https://codeql.github.com/docs/codeql-for-visual-studio-code/setting-up-codeql-in-visual-studio-code/][CodeQL extension for Visual Studio Code]].

- Install the latest version of the
  [[https://github.com/github/codeql-cli-binaries/releases][CodeQL CLI]].

- Clone this repository:
  #+begin_src sh
  git clone https://github.com/hohn/codeql-workshop-runtime-values-c
  #+end_src

- Install the CodeQL pack dependencies using the command
  =CodeQL: Install Pack Dependencies= and select =exercises=,
  =solutions=, =exercises-tests=, =session=, =session-db= and
  =solutions-tests= from the list of packs.

- If you have CodeQL on your PATH, build the database using
  =build-database.sh= and load the database with the VS Code CodeQL
  extension. It is at =session-db/cpp-runtime-values-db=.

  - Alternatively, you can download
    [[https://drive.google.com/file/d/1N8TYJ6f4E33e6wuyorWHZHVCHBZy8Bhb/view?usp=sharing][this
    pre-built database]].

- If you do *not* have CodeQL on your PATH, build the database using the
  unit test sytem. Choose the =TESTING= tab in VS Code, run the
  =session-db/DB/db.qlref= test. The test will fail, but it leaves a
  usable CodeQL database in =session-db/DB/DB.testproj=.

- ❗Important❗: Run =initialize-qltests.sh= to initialize the tests.
  Otherwise, you will not be able to run the QLTests in
  =exercises-tests=.

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:
This workshop focuses on analyzing and relating two values --- array
access indices and memory allocation sizes --- in order to identify
simple cases of out-of-bounds array accesses.

The following snippets demonstrate how an out-of-bounds array access can
occur:

#+begin_src cpp
char* buffer = malloc(10);
buffer[9] = 'a'; // ok
buffer[10] = 'b'; // out-of-bounds
#+end_src

A more complex example:

#+begin_src cpp
char* buffer;
if(rand() == 1) {
    buffer = malloc(10);
}
else {
    buffer = malloc(11);
}
size_t index = 0;
if(rand() == 1) {
    index = 10;
}
buffer[index]; // potentially out-of-bounds depending on control-flow
#+end_src

Another common case /not/ covered in this introductory workshop involves
loops, as follows:

#+begin_src cpp
int elements[5];
for (int i = 0; i <= 5; ++i) {
    elements[i] = 0;
}
#+end_src

To find these issues, we can implement an analysis that tracks the upper
or lower bounds on an expression and, combined with data-flow analysis
to reduce false-positives, identifies cases where the index of the array
results in an access beyond the allocated size of the buffer.

* A Note on the Scope of This Workshop
  :PROPERTIES:
  :CUSTOM_ID: a-note-on-the-scope-of-this-workshop
  :END:
This workshop is not intended to be a complete analysis that is useful
for real-world cases of out-of-bounds analyses for reasons including but
not limited to:

- Missing support for loops and recursion
- No interprocedural analysis
- Missing size calculation of arrays where the element size is not 1
- No support for pointer arithmetic or in general, operations other than
  addition and subtraction
- Overly specific modelling of a buffer access as an array expression

The goal of this workshop is rather to demonstrate the building blocks
of analyzing run-time values and how to apply those building blocks to
modelling a common class of vulnerability. A more comprehensive and
production-appropriate example is the
[[https://github.com/github/codeql-coding-standards/blob/main/c/common/src/codingstandards/c/OutOfBounds.qll][OutOfBounds.qll
library]] from the
[[https://github.com/github/codeql-coding-standards][CodeQL Coding
Standards repository]].

* Session/Workshop notes
  :PROPERTIES:
  :CUSTOM_ID: sessionworkshop-notes
  :END:
Unlike the the [[#org3b74422][exercises]] which use the /collection/ of
test problems in =exercises-test=, a workshop follows
=session/session.ql= and uses a /single/ database built from a single,
larger segment of code.

* Exercises
  :PROPERTIES:
  :CUSTOM_ID: exercises
  :END:
These exercises use the collection of test problems in =exercises-test=.

** Exercise 1
   :PROPERTIES:
   :CUSTOM_ID: exercise-1
   :END:
In the first exercise we are going to start by modelling a dynamic
allocation with =malloc= and an access to that allocated buffer with an
array expression. The goal of this exercise is to then output the array
access, buffer, array size, and buffer offset.

The [[file:solutions-tests/Exercise1/test.c][first test-case]] is a
simple one, as both the allocation size and array offsets are constants.

For this exercise, connect the allocation(s), the array accesses, and
the sizes in each.

Run the query and ensure that you have three results.

*** Hints
    :PROPERTIES:
    :CUSTOM_ID: hints
    :END:
1. =Expr::getValue()::toInt()= can be used to get the integer value of a
   constant expression.
2. Use =DataFlow::localExprFlow()= to relate the allocated buffer to the
   array base.

** Exercise 2
   :PROPERTIES:
   :CUSTOM_ID: exercise-2
   :END:
This exercise uses the same C source code with an addition: a constant
array size propagated [[file:solutions-tests/Exercise2/test.c][via a
variable]].

XX:

1. start with query.
   =elementSize = access.getArrayBase().getUnspecifiedType().(PointerType).getBaseType().getSize()=
2. convert to predicate.
3. then use classes, if desired. =class BufferAccess extends ArrayExpr=
   is different from those below.

*** Task 1
    :PROPERTIES:
    :CUSTOM_ID: task-1
    :END:
With the basic elements of the analysis in place, refactor the query
into two classes: =AllocationCall= and =ArrayAccess=. The
=AllocationCall= class should model a call to =malloc= and the
=ArrayAccess= class should model an array access expression
(=ArrayExpr=).

*** Task 2
    :PROPERTIES:
    :CUSTOM_ID: task-2
    :END:
Next, note the missing results for the cases in =test_const_var= which
involve a variable access rather than a constant. The goal of this task
is to implement the =getSourceConstantExpr=, =getFixedSize=, and
=getFixedArrayOffset= predicates to handle the case where the allocation
size or array index are variables rather than integer constants.

Use local data-flow analysis to complete the =getSourceConstantExpr=
predicate. The =getFixedSize= and =getFixedArrayOffset= predicates can
be completed using =getSourceConstantExpr=.

** Exercise 3
   :PROPERTIES:
   :CUSTOM_ID: exercise-3
   :END:
This exercise has slightly more C source code
[[file:solutions-tests/Exercise3/test.c][here]].

XX: test_const_branch buf[100] with size == 100

Running the query from Exercise 2 against the database yields a
significant number of missing or incorrect results. The reason is that
although great at identifying compile-time constants and their use,
data-flow analysis is not always the right tool for identifying the
/range/ of values an =Expr= might have, particularly when multiple
potential constants might flow to an =Expr=.

XX: explain using source code.

XX: autogen accessor predicates?

The CodeQL standard library several mechanisms for addressing this
problem; in the remainder of this workshop we will explore two of them:
=SimpleRangeAnalysis= and, later, =GlobalValueNumbering=.

Although not in the scope of this workshop, a standard use-case for
range analysis is reliably identifying integer overflow and validating
integer overflow checks.

*** Task 1
    :PROPERTIES:
    :CUSTOM_ID: task-1-1
    :END:
Change the implementation of the =getFixedSize= and
=getFixedArrayOffset= predicates to use the =SimpleRangeAnalysis=
library rather than data-flow. Specifically, the relevant predicates are
=upperBound= and =lowerBound=. Decide which to use for this exercise
(=upperBound=, =lowerBound=, or both).

Experiment with different combinations of the =upperBound= and
=lowerBound= predicates to see how they impact the results.

Hint:

Use =upperBound= for both predicates.

*** Task 2
    :PROPERTIES:
    :CUSTOM_ID: task-2-1
    :END:
Implement the =isOffsetOutOfBoundsConstant= predicate to check if the
array offset is out-of-bounds. A template has been provided for you.

You should now have five results.

** Exercise 4
   :PROPERTIES:
   :CUSTOM_ID: exercise-4
   :END:
XX: The range analysis already handles conditional branches; we don't
have to use guards on data flow -- don't implement your own interpreter
if you can use the library.

Again, a slight longer C [[file:solutions-tests/Exercise4/test.c][source
snippet]].

A common issue with the =SimpleRangeAnalysis= library is handling of
cases where the bounds are undeterminable at compile-time on one or more
paths. For example, even though certain paths have clearly defined
bounds, the range analysis library will define the =upperBound= and
=lowerBound= of =val= as =INT_MIN= and =INT_MAX= respectively:

#+begin_src cpp
int val = rand() ? rand() : 30;
#+end_src

A similar case is present in the =test_const_branch= and
=test_const_branch2= test-cases in the =Exercise3= test case. Note the
issues with your Exercise 3 for these test-cases. In these cases, it is
necessary to augment range analysis with data-flow and restrict the
bounds to the upper or lower bound of computable constants that flow to
a given expression.

*** Task 1
    :PROPERTIES:
    :CUSTOM_ID: task-1-2
    :END:
To refine the bounds used for validation, start by implementing
=getSourceConstantExpr=. Then, implement =getMaxStatedValue= according
to the
[[https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#qldoc-qldoc][QLDoc]]
documentation in =Exercise4.ql=.

** Task 2
   :PROPERTIES:
   :CUSTOM_ID: task-2-2
   :END:
Update the =getFixedSize= and =getFixedArrayOffset= predicates to use
the =getMaxStatedValue= predicate.

You should now have six results. However, some results annotated as
=NON_COMPLIANT= in the test-case are still missing. Why is that?

Hint:

Which expression is passed to the =getMaxStatedValue= predicate?

Answer:

The missing results involve arithmetic offsets (right operand) from a
base value (left operand). The =getMaxStatedValue= predicate should only
be called on the base expression, not any =AddExpr= or =SubExpr=, as
=getMaxStatedValue= relies on data-flow analysis.

** Exercise 5
   :PROPERTIES:
   :CUSTOM_ID: exercise-5
   :END:
The [[file:solutions-tests/Exercise5/test.c][source snippet]] is
unchanged but replicated for the test.

XX: the cases
=39:14:    if (size < 199) 69:20:    if (alloc_size < 199)= need to be
exempted.

XX: examine the index expression value, and compare it to the
upper/lower bounds. /Then/ expand the query.

Since we aren't using pure range analysis via the =upperBound= and/or
=lowerBound= predicates, handling =getMaxStatedValue= for =AddExpr= and
=SubExpr= is necessary.

In the interest of time and deduplicating work in this workshop, only
implement that check in =getFixedArrayOffset=. In a real-world scenario,
it would be necessary to analyze offsets of both the buffer allocation
size and array index.

Complete the following predicates:

- =getExprOffsetValue=
- =getFixedArrayOffset=

You should now see nine results.

** Exercise 6
   :PROPERTIES:
   :CUSTOM_ID: exercise-6
   :END:
TODO: intro to GVN write-up here TODO: finish below instructions

XX: reference:
[[https://codeql.github.com/docs/codeql-language-guides/hash-consing-and-value-numbering/]]
Global value numbering only knows that runtime values are equal; they
are not comparable (=<, >, <== etc.), and the /actual/ value is not
known.

XX: Look for and use /relative/ values between allocation and use. To do
this, use GVN.

XX: This is the case in

#+begin_example
void test_gvn_var(unsigned long x, unsigned long y, unsigned long sz)
{
    char *buf = malloc(sz * x * y);
    buf[sz * x * y - 1]; // COMPLIANT
    buf[sz * x * y];     // NON_COMPLIANT
    buf[sz * x * y + 1]; // NON_COMPLIANT
}
#+end_example

XX: Range analyis won't bound =sz * x * y=, so switch to global value
numbering. Or use hashcons.

XX: global value numbering finds expressions with the same known value,
independent of structure.

#+begin_example
...
globalValueNumber(e) = globalValueNumber(sizeExpr) and
e != sizeExpr
...
#+end_example

XX: hashcons: every value gets a number based on structure. Fails on

#+begin_example
char *buf = malloc(sz * x * y);
sz = 100;
buf[sz * x * y - 1]; // COMPLIANT
#+end_example

XX: global value numbering to identify common values as first step, but
for expressions like

#+begin_example
buf[sz * x * y - 1]; // COMPLIANT
#+end_example

we have to "evaluate" the expressions -- or at least bound them.

The final exercise is to implement the =isOffsetOutOfBoundsGVN=
predicate to [...]




